#!/usr/local/bin/ruby26

#
# termbar.yawara
#
# vim set ft=ruby:
#

require 'pp'

#RES = "[0;0m"
#DGY = "[90m"
RED = "[31m"
GRN = "[32m"
  #
  # reset 0;0
  # bright 1 dim 2 underlined 4 blink 5 reverse 7 hidden 8 default 39
  # black 30 red 31 green 32 yellow 33 blue 34 magenta 35 cyan 36
  # light_gray 37 dark_gray 90 light_red 91 light_green 92
  # light_yellow 93 light_blue 94 light_magenta 95 light_cyan 96 white 97
  # bg_default 49 bg_black 40 bg_red 41 bg_green 42 bg_yellow 43 bg_blue 44
  # bg_magenta 45 bg_cyan 46 bg_light_gray 47 bg_dark_gray 100
  # bg_light_red 101 bg_light_green 102 bg_light_yellow 103
  # bg_light_blue 104 bg_light_magenta 105 bg_light_cyan 106
  # bg_white 107

RED_PERBAT = 33.3
  # when battery percentage is less than that, go red

print "\e[?25l"
  # hide cursor
  # https://en.wikipedia.org/wiki/ANSI_escape_code#Terminal_output_sequences


#debug = false
#  #
#Signal.trap('USR1') do
#  debug = ! debug
#end

cols = `tput cols`.to_i


begin

  mprocs = [ nil, '0', '0' ]

  loop do

    # gather info

    hw = `sysctl hw`
      .split("\n")
      .inject({}) { |h, l| k, v = l.split('='); h[k.split('.', 2).last] = v; h }
    hws = hw
      .inject({}) { |h, (k, v)| h[k[8..-1]] = v if k.match(/\Asensors\./); h }
    ifconfig = `ifconfig`
      .split("\n")
      .collect(&:strip)
    top = `top -1 -d 1 -p 1`
      .split("\n")

    machine = %w[ vendor product model _machine ]
      .collect { |k| k[0, 1] == '_' ? "(#{hw[k[1..-1]]})" : hw[k] }
      .compact
      .join(' ')
      .gsub(/ Inc\.|\(R\)|\(TM\)| CPU/, '')

    nwid = ifconfig
      .select { |l| l.match(/ieee80211/) }
      .first
      .match(/ join ([^ ]+) /)[1] rescue '(no nwid)'
    ip = ifconfig
      .select { |l| l.match(/inet \d/) }
      .reject { |l| l.match(/ 127\.0\.0\.1 /) }
      .first
      .match(/inet ([^ ]+) /)[1] rescue '(no ip)'
    net = "net #{nwid} #{ip}"

    lod = top[0].split(/\s+/)[2, 3].join(' ').gsub(/,\s+/, ' ')

    up = top[1].match(/ up (.+)$/)[1] rescue '0 days'
    up = 'up ' + up.gsub(/[,\s]+/, ' ').strip

    mprocs = top[1].match(/^(\d+) processes: (\d+) idle/) || mprocs
    procs = [ mprocs[1].to_i, mprocs[1].to_i - mprocs[2].to_i ]
    procs = sprintf("procs %3d/%1d load %s", procs[0], procs[1], lod)

    mem = top[3].match(/Real: ([^\/]+)\/([^\/]+) /) || [ nil, '0', '0' ]
    fmem = top[3].match(/ Free: ([^ ]+) /)[1] rescue '0'
    mem = "mem a#{mem[1]} t#{mem[2]} f#{fmem}"

    temp = (hws['cpu0.temp0'].split(' ')[0] rescue '0').to_f
    speed = hw['cpuspeed'] || '0'
    idle = (top[2].match(/([^ ]+)% idle$/)[1].to_f) rescue 100.0
    cpu = sprintf("cpu s%4s %3.2f%% t%0.2fC", speed, 100.0 - idle, temp)

    fan = "fan #{(hws['acpithinkpad0.fan0'].split(/\s+/)[0] rescue '0')}rpm"

    dirbat = hws['acpibat0.raw0'].match(/discharging/) ? 'd' : 'c'
    rembat = hws['acpibat0.watthour3'].split(' Wh').first.to_f
    maxbat = hws['acpibat0.watthour4'].split(' Wh').first.to_f
    perbat = rembat / maxbat * 100
    redbat = perbat < RED_PERBAT && dirbat == 'd'
    bat = sprintf('bat %2.2f%% %s', perbat, dirbat)
    bat = bat + '  /!\\' if redbat && Time.now.to_i % 2 == 0

    now = Time.now.to_s

    ls = [ machine, net, procs, mem, cpu, fan, up, bat ].join(' | ') + ' '
    rs = [ now ].join(' | ')

    # output

    rss = ((Time.now.to_i % 2) == 0) ? rs.gsub(/:/, ' ') : rs

    space = cols - ls.length - rss.length
    space = 10 if space < 1
    space = ' ' * space

    ls = ls.gsub(/ bat \d+\.\d+% d(  [^ ]+)?/) { |m| RED + m + GRN } if redbat
      # color after the text lengths have been used to position the text...

    print "\n" << GRN << ls << space << rss

    sleep 1
  end

rescue => err

  print "\n" + err.inspect + " at " + err.backtrace[0]
  sleep
end

